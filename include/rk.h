#include <cmath>
#include <fstream>
#include <functional>
#include <iostream>
#include <memory>
#include <vector>

// Define DynFun as a std::function for better type safety
using DynFun = std::function<void(double, const std::vector<double>&, std::vector<double>&)>;

enum IntegrationMethod { Euler, MidPoint, RungeKutta, RK_2, RK_4A, RK_4B, RK_45, RK_5, RK_10 };

/******************************************************************************
 *                           Utility Functions                                *
 ******************************************************************************/

/* Prints the current time and state to the log file */
void printState(std::ofstream& file, double t, const std::vector<double>& z) {
  file << t;
  for (const auto& val : z) {
    file << ", " << val;
  }
  file << "\n";
}

/******************************************************************************
 *                     Hard-Coded Low-Order Methods                           *
 ******************************************************************************/

/* Takes a simple euler step for the system */
void eulerStep(DynFun dynFun, double t0, double t1, const std::vector<double>& z0,
               std::vector<double>& z1) {
  double dt = t1 - t0;
  std::vector<double> dz(z0.size());

  dynFun(t0, z0, dz);

  for (size_t i = 0; i < z0.size(); i++) {
    z1[i] = z0[i] + dt * dz[i];
  }
}

/* Time step using the mid-point method */
void midPointStep(DynFun dynFun, double tLow, double tUpp, const std::vector<double>& zLow,
                  std::vector<double>& zUpp) {
  double dt = tUpp - tLow;

  /// Stage 0
  std::vector<double> f0(zLow.size());
  dynFun(tLow, zLow, f0);

  /// Stage 1
  std::vector<double> z1(zLow.size());
  for (size_t i = 0; i < zLow.size(); i++) {
    z1[i] = zLow[i] + 0.5 * dt * f0[i];
  }
  std::vector<double> f1(zLow.size());
  dynFun(tLow + 0.5 * dt, z1, f1);

  /// Collect Stages:
  for (size_t i = 0; i < zLow.size(); i++) {
    zUpp[i] = zLow[i] + dt * f1[i];
  }
}

/* Time step using 4th-order "Classical" Runge Kutta */
void rungeKuttaStep(DynFun dynFun, double tLow, double tUpp, const std::vector<double>& zLow,
                    std::vector<double>& zUpp) {
  double dt = tUpp - tLow;

  /// Stage 0
  std::vector<double> f0(zLow.size());
  dynFun(tLow, zLow, f0);

  /// Stage 1
  std::vector<double> z1(zLow.size());
  for (size_t i = 0; i < zLow.size(); i++) {
    z1[i] = zLow[i] + 0.5 * dt * f0[i];
  }
  std::vector<double> f1(zLow.size());
  dynFun(tLow + 0.5 * dt, z1, f1);

  /// Stage 2
  std::vector<double> z2(zLow.size());
  for (size_t i = 0; i < zLow.size(); i++) {
    z2[i] = zLow[i] + 0.5 * dt * f1[i];
  }
  std::vector<double> f2(zLow.size());
  dynFun(tLow + 0.5 * dt, z2, f2);

  /// Stage 3
  std::vector<double> z3(zLow.size());
  for (size_t i = 0; i < zLow.size(); i++) {
    z3[i] = zLow[i] + dt * f2[i];
  }
  std::vector<double> f3(zLow.size());
  dynFun(tLow + dt, z3, f3);

  /// Collect Stages:
  for (size_t i = 0; i < zLow.size(); i++) {
    zUpp[i] = zLow[i] + (dt / 6) * (f0[i] + 2.0 * f1[i] + 2.0 * f2[i] + f3[i]);
  }
}

/******************************************************************************
 *                      Simulation Wrapper Function                           *
 ******************************************************************************/

/* Runs several time steps using euler integration */
void simulate(DynFun dynFun, double t0, double t1, const std::vector<double>& z0,
              std::vector<double>& z1, int nStep, IntegrationMethod method) {
  double dt = (t1 - t0) / static_cast<double>(nStep);
  double tLow = t0;
  std::vector<double> zLow = z0;
  std::vector<double> zUpp(z0.size());

  /// File IO stuff:
  std::ofstream logFile("logFile.csv");

  /// Initial conditions
  printState(logFile, tLow, zLow);

  /// March forward in time:
  for (int i = 0; i < nStep; i++) {
    double tUpp = tLow + dt;
    switch (method) {
      case Euler:
        eulerStep(dynFun, tLow, tUpp, zLow, zUpp);
        break;
      case MidPoint:
        midPointStep(dynFun, tLow, tUpp, zLow, zUpp);
        break;
      case RungeKutta:
        rungeKuttaStep(dynFun, tLow, tUpp, zLow, zUpp);
        break;
      // Add other methods here as needed
      default:
        throw std::invalid_argument("Unsupported integration method");
    }

    /// Print the state of the simulation:
    printState(logFile, tUpp, zUpp);

    /// Advance temp variables:
    tLow = tUpp;
    zLow = zUpp;
  }

  logFile.close();
}

using DynFun = std::function<void(double, const std::vector<double>&, std::vector<double>&)>;

/* Time step using 4th-order "Classical" Runge Kutta */
void rungeKuttaStep(DynFun dynFun, double tLow, double tUpp, const std::vector<double>& zLow,
                    std::vector<double>& zUpp) {
  double dt = tUpp - tLow;

  /// Stage 0
  std::vector<double> f0(zLow.size());
  dynFun(tLow, zLow, f0);

  /// Stage 1
  std::vector<double> z1(zLow.size());
  for (size_t i = 0; i < zLow.size(); i++) {
    z1[i] = zLow[i] + 0.5 * dt * f0[i];
  }
  std::vector<double> f1(zLow.size());
  dynFun(tLow + 0.5 * dt, z1, f1);

  /// Stage 2
  std::vector<double> z2(zLow.size());
  for (size_t i = 0; i < zLow.size(); i++) {
    z2[i] = zLow[i] + 0.5 * dt * f1[i];
  }
  std::vector<double> f2(zLow.size());
  dynFun(tLow + 0.5 * dt, z2, f2);

  /// Stage 3
  std::vector<double> z3(zLow.size());
  for (size_t i = 0; i < zLow.size(); i++) {
    z3[i] = zLow[i] + dt * f2[i];
  }
  std::vector<double> f3(zLow.size());
  dynFun(tLow + dt, z3, f3);

  /// Collect Stages:
  for (size_t i = 0; i < zLow.size(); i++) {
    zUpp[i] = zLow[i] + (std::fabs(dt) / 6) * (f0[i] + 2.0 * f1[i] + 2.0 * f2[i] + f3[i]);
  }
}

/* Time step using 10th-order Runge-Kutta-Fehlberg. Data for method from:
http://sce.uhcl.edu/rungekutta/rk108.txt
Paper:  "A tenth-order Runge-Kutta method with error estimate"
By Feagin*/

static std::vector<double> RK10__A = {
    0.000000000000000000000000000000000000000000000000000000000000,
    0.100000000000000000000000000000000000000000000000000000000000,
    0.539357840802981787532485197881302436857273449701009015505500,
    0.809036761204472681298727796821953655285910174551513523258250,
    0.309036761204472681298727796821953655285910174551513523258250,
    0.981074190219795268254879548310562080489056746118724882027805,
    0.833333333333333333333333333333333333333333333333333333333333,
    0.354017365856802376329264185948796742115824053807373968324184,
    0.882527661964732346425501486979669075182867844268052119663791,
    0.642615758240322548157075497020439535959501736363212695909875,
    0.357384241759677451842924502979560464040498263636787304090125,
    0.117472338035267653574498513020330924817132155731947880336209,
    0.833333333333333333333333333333333333333333333333333333333333,
    0.309036761204472681298727796821953655285910174551513523258250,
    0.539357840802981787532485197881302436857273449701009015505500,
    0.100000000000000000000000000000000000000000000000000000000000,
    1.00000000000000000000000000000000000000000000000000000000000};

static std::vector<double> RK10__C = {
    0.0333333333333333333333333333333333333333333333333333333333333,
    0.0250000000000000000000000000000000000000000000000000000000000,
    0.0333333333333333333333333333333333333333333333333333333333333,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.0500000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.0400000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.189237478148923490158306404106012326238162346948625830327194,
    0.277429188517743176508360262560654340428504319718040836339472,
    0.277429188517743176508360262560654340428504319718040836339472,
    0.189237478148923490158306404106012326238162346948625830327194,
    -0.0400000000000000000000000000000000000000000000000000000000000,
    -0.0500000000000000000000000000000000000000000000000000000000000,
    -0.0333333333333333333333333333333333333333333333333333333333333,
    -0.0250000000000000000000000000000000000000000000000000000000000,
    0.0333333333333333333333333333333333333333333333333333333333333};

static std::vector<double> RK10__B = {
    0.100000000000000000000000000000000000000000000000000000000000,
    -0.915176561375291440520015019275342154318951387664369720564660,
    1.45453440217827322805250021715664459117622483736537873607016,
    0.202259190301118170324681949205488413821477543637878380814562,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.606777570903354510974045847616465241464432630913635142443687,
    0.184024714708643575149100693471120664216774047979591417844635,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.197966831227192369068141770510388793370637287463360401555746,
    -0.0729547847313632629185146671595558023015011608914382961421311,
    0.0879007340206681337319777094132125475918886824944548534041378,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.410459702520260645318174895920453426088035325902848695210406,
    0.482713753678866489204726942976896106809132737721421333413261,
    0.0859700504902460302188480225945808401411132615636600222593880,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.330885963040722183948884057658753173648240154838402033448632,
    0.489662957309450192844507011135898201178015478433790097210790,
    -0.0731856375070850736789057580558988816340355615025188195854775,
    0.120930449125333720660378854927668953958938996999703678812621,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.260124675758295622809007617838335174368108756484693361887839,
    0.0325402621549091330158899334391231259332716675992700000776101,
    -0.0595780211817361001560122202563305121444953672762930724538856,
    0.110854379580391483508936171010218441909425780168656559807038,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    -0.0605761488255005587620924953655516875526344415354339234619466,
    0.321763705601778390100898799049878904081404368603077129251110,
    0.510485725608063031577759012285123416744672137031752354067590,
    0.112054414752879004829715002761802363003717611158172229329393,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    -0.144942775902865915672349828340980777181668499748506838876185,
    -0.333269719096256706589705211415746871709467423992115497968724,
    0.499269229556880061353316843969978567860276816592673201240332,
    0.509504608929686104236098690045386253986643232352989602185060,
    0.113976783964185986138004186736901163890724752541486831640341,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    -0.0768813364203356938586214289120895270821349023390922987406384,
    0.239527360324390649107711455271882373019741311201004119339563,
    0.397774662368094639047830462488952104564716416343454639902613,
    0.0107558956873607455550609147441477450257136782823280838547024,
    -0.327769124164018874147061087350233395378262992392394071906457,
    0.0798314528280196046351426864486400322758737630423413945356284,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    -0.0520329686800603076514949887612959068721311443881683526937298,
    -0.0576954146168548881732784355283433509066159287152968723021864,
    0.194781915712104164976306262147382871156142921354409364738090,
    0.145384923188325069727524825977071194859203467568236523866582,
    -0.0782942710351670777553986729725692447252077047239160551335016,
    -0.114503299361098912184303164290554670970133218405658122674674,
    0.985115610164857280120041500306517278413646677314195559520529,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.330885963040722183948884057658753173648240154838402033448632,
    0.489662957309450192844507011135898201178015478433790097210790,
    -1.37896486574843567582112720930751902353904327148559471526397,
    -0.861164195027635666673916999665534573351026060987427093314412,
    5.78428813637537220022999785486578436006872789689499172601856,
    3.28807761985103566890460615937314805477268252903342356581925,
    -2.38633905093136384013422325215527866148401465975954104585807,
    -3.25479342483643918654589367587788726747711504674780680269911,
    -2.16343541686422982353954211300054820889678036420109999154887,
    0.895080295771632891049613132336585138148156279241561345991710,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.197966831227192369068141770510388793370637287463360401555746,
    -0.0729547847313632629185146671595558023015011608914382961421311,
    0.0000000000000000000000000000000000000000000000000000000000000,
    -0.851236239662007619739049371445966793289359722875702227166105,
    0.398320112318533301719718614174373643336480918103773904231856,
    3.63937263181035606029412920047090044132027387893977804176229,
    1.54822877039830322365301663075174564919981736348973496313065,
    -2.12221714704053716026062427460427261025318461146260124401561,
    -1.58350398545326172713384349625753212757269188934434237975291,
    -1.71561608285936264922031819751349098912615880827551992973034,
    -0.0244036405750127452135415444412216875465593598370910566069132,
    -0.915176561375291440520015019275342154318951387664369720564660,
    1.45453440217827322805250021715664459117622483736537873607016,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    -0.777333643644968233538931228575302137803351053629547286334469,
    0.000000000000000000000000000000000000000000000000000000000000,
    -0.0910895662155176069593203555807484200111889091770101799647985,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.0910895662155176069593203555807484200111889091770101799647985,
    0.777333643644968233538931228575302137803351053629547286334469,
    0.100000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    -0.157178665799771163367058998273128921867183754126709419409654,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.157178665799771163367058998273128921867183754126709419409654,
    0.181781300700095283888472062582262379650443831463199521664945,
    0.675000000000000000000000000000000000000000000000000000000000,
    0.342758159847189839942220553413850871742338734703958919937260,
    0.000000000000000000000000000000000000000000000000000000000000,
    0.259111214548322744512977076191767379267783684543182428778156,
    -0.358278966717952089048961276721979397739750634673268802484271,
    -1.04594895940883306095050068756409905131588123172378489286080,
    0.930327845415626983292300564432428777137601651182965794680397,
    1.77950959431708102446142106794824453926275743243327790536000,
    0.100000000000000000000000000000000000000000000000000000000000,
    -0.282547569539044081612477785222287276408489375976211189952877,
    -0.159327350119972549169261984373485859278031542127551931461821,
    -0.145515894647001510860991961081084111308650130578626404945571,
    -0.259111214548322744512977076191767379267783684543182428778156,
    -0.342758159847189839942220553413850871742338734703958919937260,
    -0.675000000000000000000000000000000000000000000000000000000000};

const int RK10__nStage = 17;

void RK_STEP(DynFun dynFun, double tLow, double tUpp, std::vector<double>& zLow,
             std::vector<double>& zUpp, const std::vector<double>& A, const std::vector<double>& B,
             const std::vector<double>& C, int nStage) {
  int nDim = zLow.size();
  /// Allocate memory:
  std::vector<double> t(nStage);
  std::vector<std::vector<double>> z(nStage, std::vector<double>(nDim));
  std::vector<std::vector<double>> f(nStage, std::vector<double>(nDim));

  /// Populate time grid:
  double dt = tUpp - tLow;
  for (int iStage = 0; iStage < nStage; iStage++) {
    t[iStage] = tLow + dt * A[iStage];
  }

  /// Initial State:
  z[0] = zLow;

  /// Dynamics at initial point:
  dynFun(t[0], z[0], f[0]);

  /// March through each stage:
  for (int iStage = 1; iStage < nStage; iStage++) {
    for (int iDim = 0; iDim < nDim; iDim++) {
      double sum = 0.0;
      for (int j = 0; j < iStage; j++) {
        int idx = iStage * (iStage - 1) / 2 + j;  // Triangle numbers
        sum += B[idx] * f[j][iDim];
      }
      z[iStage][iDim] = zLow[iDim] + dt * sum;
    }
    dynFun(t[iStage], z[iStage], f[iStage]);
  }

  /// Compute the final estimate:
  for (int iDim = 0; iDim < nDim; iDim++) {
    double sum = 0.0;
    for (int iStage = 0; iStage < nStage; iStage++) {
      sum += C[iStage] * f[iStage][iDim];
    }
    zUpp[iDim] = zLow[iDim] + dt * sum;
  }
}

void rk10step(DynFun dynFun, double tLow, double tUpp, std::vector<double>& zLow,
              std::vector<double>& zUpp) {
  RK_STEP(dynFun, tLow, tUpp, zLow, zUpp, RK10__A, RK10__B, RK10__C, RK10__nStage);
}

// std::vector<double> n_nu_up(m_energySize, 0.);
// auto f = [&](double z, const std::vector<double>& n, std::vector<double>& dndz) {
//   for (size_t i = 1; i < m_eAxis.size() - 1; ++i) {
//     dndz.at(i) = dtdz * m_q_nu[i];
//     dndz.at(i) -= 3. / (1. + z) * n[i];

//     const auto E = m_eAxis[i];
//     const auto Eup = m_eAxis[i + 1];
//     const auto dE = Eup - E;
//     const auto b = dtdz * E * H;
//     const auto bUp = dtdz * Eup * H;

//     dndz.at(i) += (bUp * n[i + 1] - b * n[i]) / dE;
//   }
// };
// rungeKuttaStep(f, z, z - dz, m_n_nu, n_nu_up);

// m_n_nu = std::move(n_nu_up);